# 5. 연관관계 매핑2

# 연관관계 매핑 시 고려사항

## 1. 다중성

- 다대일 (N : 1)
- 일대다 (1 : N)
- 일대일 (1 : 1)
- 다대다 (N : M)

## 2. 단방향, 양방향

- 테이블
    - **외래 키로 연관관계를 맺는다**
    - **외래 키 하나로 양쪽 조인 가능**하기 때문에 **방향이라는 개념이 없다.**
- 객체
    - **참조(주소)로 연관관계를 맺는다.**
    - **참조용 필드가 있는 쪽으로만 참조가 가능하다**
        - 한쪽만 참조하면 단방향
        - 양쪽이 서로 참조하면 양방향 = 단방향 두 개

## 3. 연관관계 주인

- 객체 양방향 관계는 참조가 2군데 있으므로 둘 중 **외래 키를 관리할 곳을 지정**해야 한다.
    - 연관관계의 **주인**: **외래 키를 관리하는 참조**
    - 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

# 다대일 (N : 1)

> **`다`가 연관관계의 주인**
> 

## 다대일 단방향

- 멤버와 팀을 보면, 여러 맴버가 한 팀에 속할 수 있으므로 다대일 관계라고 할 수 있다

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled.png)

- 가장 많이 사용하는 연관관계

### 객체 연관관계

- 회원 객체는 `Member.team` 필드로 팀 객체와 연관관계를 맺는다.
- 회원 객체와 팀 객체는 단방향 관계다. 회원은 `Member.team` 필드를 통해서 팀을 알 수 있지만, 팀은 회원을 알 수 없다.

### 테이블 연관관계

- 회원 테이블은 `TEAM_ID` 외래 키로 팀 테이블과 연관관계를 맺는다.
- 회원 테이블과 팀 테이블은 양방향 관계다. 회원 테이블의 `TEAM_ID` 외래 키를 통해서 회원과 팀을 조인할 수 있고 반대로 팀과 회원도 조인할 수 있다.

> **참조를 통한 연관관계는 언제나 단방향이다.**
> 

## 다대일 양방향

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%201.png)

- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발
- 양방향 연관관계는 항상 서로를 참조해야 함

# 일대다 (1:N)

> **`일`이 연관관계의 주인 (권장하지 않음)**
> 

## **일대다 단방향**

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%202.png)

- 객체) `Team`을 중심으로 외래 키를 관리하고, `Member` 입장에서는 `Team`에 대한 참조가 없다.
- 테이블) **테이블 일대다 관계**는 **항상 다(`N`) 쪽에 외래 키가 있다.**
→ 객체와 테이블의 차이 때문에 **반대편 테이블의 외래 키를 관리하는 특이한 구조**

### 권장하지 않음

- 테이블에서는 항상 다(`N`) 쪽에 외래 키가 있기 때문에 **패러다임 충돌이 발생**한다.
- **`@JoinColumn`**을 꼭 사용해야 한다! 아니면 **조인 테이블 방식**을 사용해야 한다.
- 실무에서는 테이블이 수십 개 이상 운영되는데, 관리 및 트레이싱이 어렵다.
- 객체 `Team`의 `List members` 값을 변경하면 다른 테이블(`Member`) 속 외래 키 `TEAM_ID`를 업데이트 해줘야 한다.
- 엔티티가 관리하는 외래 키가 다른 테이블에 있음
- 연관관계 관리를 위해 추가로 `UPDATE SQL` 실행해야 한다.→ 일대다 단방향 매핑보다는 **다대일 양방향 매핑을 사용하자!**

## **일대다 양방향**

![https://velog.velcdn.com/images/yys/post/23d6d978-c026-46ac-93cf-586276f8a387/image.png](https://velog.velcdn.com/images/yys/post/23d6d978-c026-46ac-93cf-586276f8a387/image.png)

- 이런 매핑은 공식적으로 존재하지 x
- @JoinColumn(insertable=false, updatable= false)
- **읽기 전용 필드를 사용**해서 양방향처럼 사용하는 방법
- 해당 속성 주지 않으면 **연관관계 주인 2개인 것 처럼되서 문제가 생긴다**

→ 그냥 **다대일 양방향을 사용**

# **일대일[1:1]**

- 다대일과 비슷, 외래 키에 db 유니크 제약조건이 추가된 것이다
- 주 테이블이나 대상 테이블 중에 **외래 키 선택 가능**
    - 주 테이블이 외래 키 소유
        - 외래 키를 객체 참조처럼 쓸 수 있어서 객체 지향 개발에 편리하다.
        - 주 테이블만 확인해도 대상 테이블과 연관 관계를 확인할 수 있다.
    - 대상 테이블이 외래 키 소유
        - 일반적인 DB 개발자들은 이 방법을 선호한다.
        - 테이블 관계를 `일대일`에서 `일대다`로 변경할 때 테이블 구조가 그대로 유지된다.
- **일대일 관계에서는 엔티티에 있는 외래 키를 직접 관리해야** 한다. (주인이어야 한다)

### 주 테이블 외래 키 단방향

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%203.png)

• 다대일(`@ManyToOne`) 단방향 매핑과 유사하다.

### 주 테이블 외래 키 **양방향**

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%204.png)

- 다대일 양방향 매핑처럼 **외래키가 있는 곳이 연관관계의 주인**
- 반대편은 `mappedBy` 적용

### **대상 테이블 외래 키 단방향**

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%205.png)

- **단방향 관계는 JPA 지원 X**

### **대상 테이블 외래 키 방향**

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%206.png)

- 대상 엔티티의 참조를 외래 키와 매핑하면 됨
- 일대일 주 테이블 외래키 양방향과 같다

### 일대일 정리

- 주 테이블에 외래 키
    - 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
    - 객체지향 개발자가 선호
    - JPA 매핑 편리
    - 장점 : **주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인** 가능
    - 단점 : 값이 없으면 외래 키에 null 허용
- 대상 테이블에 외래 키
    - 데이터베이스 개발자가 선호
    - 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지
    - 단점 : 무조건 양방향으로, 단방향으로 JPA 지원 안함.
        - 프록시 기능의 한계로 **지연로딩으로 설정해도 항상 즉시로딩**
        - where문을 이용해 쿼리를 날려야 하므로 즉시 로딩

> JPA 입장에서 프록시 객체를 만들려면, 해당 엔티티의 참조에 매핑되는 값이 테이블에 있는지 없는지 알아야 한다. 지연 로딩 시 참조에 값이 있다면 프록시로 초기화하고, 값이 없으면 그냥 null 넣어주면 되기 때문! 만약 주 테이블에 외래 키 있다면, 주 엔티티의 참조 변수에 매핑 되는 값 있는지 확인하기 위해서는 주 테이블만 검색하면 되니까 다른 대상 테이블 검색할 필요가 없어서 지연 로딩이 가능.
> 

> BUT 대상 테이블에 외래키 있는 경우, 주 테이블 가져 올 때 해당 참조에 매핑 되는 값 있는지 확인하기 위해서는 대상 테이블까지 검색해야 한다. (주 테이블에 외래 키 값이 없고, 외래 키 값이 대상테이블에 있으니까, 매핑되는 값 확인하려면 대상테이블을 검색해야한다.)어차피 대상테이블을 뒤져야하기 때문에 사실상 지연로딩을 하더라도 즉시로딩이 되버린다. 따라서 지연로딩으로 세팅하는 것이 의미가 없다.
> 

# **다대다[N:M]**

> 사용X
> 

**관계형 데이터베이스**

는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음

→ **연결 테이블을 추가**해서 일대다, 다대일 관계로 풀어내야 한다.

![Untitled](5%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC2%204d64584c1a9647308a444a8eaf7a60bc/Untitled%207.png)

- 객체는 가능하고, db는 가능하지 않음
    - **객체**는 **컬렉션을 사용**해서 객체 2개로 다대다 관계 가능
    - `@ManyToMany` 사용
    - `@JoinTable`로 연결 테이블 지정
    - 단방향, 양방향 모두 가능

### 다대다 매핑의 한계

- 연결 테이블이 단순히 연결만 하고 끝나는 경우는 없다
    - 주문 시간, 수량 같은 데이터가 들어올 수 있음
    - 중간 테이블에 다른 추가 정보를 넣을 수 없음
- 중간 테이블이 숨겨져 있어서 생각지 못한 쿼리가 나감

### **다대다 한계 극복**

- **연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)**
- `@ManyToMany` → `@OneToMany`, `@ManyToOne`
- 다대다를 써야할 때는 일대다, 다대일로 변경해서 사용하자!