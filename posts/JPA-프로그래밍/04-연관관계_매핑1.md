# 4. 연관관계 매핑1

## 연관관계의 필요성

### 테이블에 맞춘 모델링

![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled.png)

참조 대신, `MEMBER` 테이블의 외래 키, `TEAM_ID`를 그대로 사용한다.

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name="MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @Column(name="TEAM_ID")
    private Long teamId;
}

@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    private String name;
}

//팀 저장
Team team = new Team();
team.setName("TeamA"); em.persist(team);

//회원 저장
Member member = new Member();
member.setName("member1"); 
member.setTeamId(team.getId()); // 객체지향적인 방법이 아님
em.persist(member);
```

• `member.setTeamId(team.getId());` : 외래 키 식별자를 직접 다룬다.

```java
// 조회
Member findMember = em.find(Member.class, member.getId());

// 연관관계가 없음
Team findTeam = em.find(Team.class, team.getId());
```

- `member`를 조회해왔음에도 `member`가 속한 팀을 알기 위해서**`member`가 가진 `team.id`, 즉 식별자로 테이블을 검색해서 가져와야 한다.**
- **이는 연관관계가 없기 때문이며, 객체지향적인 방법이 아님**

<aside>
💡 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, **협력관계를 만들 수 없다.**

- **테이블은 외래 키로 조인**을 사용해서 연관된 테이블을 찾는다.
- **객체는 참조**를 사용해서 연관된 객체를 찾는다.
</aside>

## 단방향 연관관계

### 객체 지향 모델링

![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled%201.png)

- `TEAM`의 `id`가 아닌 **`TEAM`의 참조 값을 그대로 가져온다.**
- `MEMBER` 객체의 `TEAM` 참조와 `MEMBER` 테이블의 `TEAM_ID(FK)`를 매핑해야 한다.

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name="MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```

- 맴버 여러 명은 한 팀에 들어갈 수 있고, 팀 하나는 여러 명의 맴버를 받을 수 있다
- Member : Team = N : 1 관계 (다대일 관계) →  @ManyToOne
- **db에서는 N쪽이 외래키가 있는 곳**이다
- **외래키가 있는 곳(N)에**, `@JoinColumn`(name = **연관관계있는 엔티티의 식별자**)를 적용한다.

### ORM 매핑

![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled%202.png)

### 연관관계 저장

```java
// 팀 저장
Team team = new Team();
team.setName("TeamA");
em.persist(team);

// 회원 저장
Member member = new Member();
member.setName("member1");
member.setTeam(team); //단방향 연관관계 설정, 참조 저장
em.persist(member);
```

### **연관관계 조회 - 객체 그래프 탐색**

```java
//조회
Member findMember = em.find(Member.class, member.getId());

//참조를 사용해서 연관관계 조회
Team findTeam = findMember.getTeam();
```

### **연관관계 수정**

```java
// 새로운 팀B
Team teamB = new Team();
teamB.setName("TeamB");
em.persist(teamB);

// 회원1에 새로운 팀B 설정 
member.setTeam(teamB);
```

## 양방향 연관관계, 연관관인 주인

- 양방향 연관관계는 단방향 연관관계가 양쪽에 2개 있는 것이라고 생각하면 됨
    
    ![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled%203.png)
    
- Member Entity는 단방향과 동일
- Team Entity는 **List<Member> 컬렉션 추가**
    
    ```java
    @Entity
    public class Team {
    
        @Id
        @GeneratedValue
        @Column(name = "TEAM_ID")
        private Long id;
        
        private String name;
    
        @OneToMany(mappedBy = "team")
        private List<Member> members = new ArrayList<>();
    }
    ```
    
- 팀과 회원은 일대다 관계 → @OneToMany
- 일대다 관계를 매핑하기 위해 `@OneToMany` 를 사용
    - **`mappedBy` 속성은 양방향 매핑일 때 사용, 반대쪽 매핑 필드의 이름을 값으로 주면 된다.**
- 컬렉션은 `new ArrayList<>()`로 초기화 해 Null Point Exception을 방지해주는 것이 관례
- 양방향 매핑으로 팀 객체를 통해 멤버를 찾는 것도 가능해짐

### **반대 방향으로 객체 그래프 탐색**

```java
//조회
Team findTeam = em.find(Team.class, team.getId());

int memberSize = findTeam.getMembers().size(); //역방향 조회
```

### **객체의 양방향 관계**

![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled%204.png)

- 객체에는 양방향 연관관계가 없다.
- **단방향 연관관계 2개를 애플리케이션 로직으로 묶어 양방향인 것처럼 표현하는 것**
- 즉, 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.

```java
A → B (a.getB())
B → A (b.getA())

class A{
	B b;
}

class B{
	A a;
}
```

### **테이블 양방향 연관관계**

![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled%205.png)

- **테이블은 외래 키 하나로 양방향 연관관계를 맺는다**

```sql
SELECT *
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
```

### **양방향 매핑 규칙 - 연관관계의 주인**

- 양방향 매핑에서는 연관간계 중 하나를 주인으로 지정해야 한다.
- **연관관계의 주인만이 외래 키를 관리(등록, 수정, 삭제)할 수 있다.**
- 주인이 아닌 쪽은 읽기만 가능하다.
- 주인은 `mappedBy` 속성을 사용하지 않는다.
- 주인이 아니면 `mappedBy` 속성으로 주인을 지정해야 한다.

![Untitled](4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC1%2031e9c737da594bad8dbeba864f73fe41/Untitled%206.png)

<aside>
💡 **연관관계 주인 = 외래 키 관리자**

- 회원 테이블에 있는 `TEAM_ID` 외래 키를 관리할 관리자를 선택해야 된다.
- 만약 회원 엔티티에 있는 `Member.team`을 주인으로 선택하면 자기 테이블에 있는 외래 키를 관리하면 된다.
- 하지만 팀 엔티티에 있는 `Team.members`를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 한다.
- 이 경우 `Team.members`가 있는 `Team` 엔티티는 `TEAM` 테이블에 매핑되어 있는데 관리해야할 외래 키는 `MEMBER`에 있기 때문이다.
</aside>

### **연관관계의 주인 - 외래 키가 있는 곳**

- **연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정한다.**
- **db입장**에서 보면 **외래 키가 있는곳이 ‘다’이며 무조건 연관관계의 주인이 된다**

### **주의 사항**

- 연관관계 주인 값을 입력하지 않으면 외래 키 데이터가 들어가지 않음
    
    ```java
    Team team = new Team();
    team.setName("TeamA");
    em.persist(team);
    
    Member member = new Member();
    member.setName("member1");
    
    //역방향(주인이 아닌 방향)만 연관관계 설정
    team.getMembers().add(member);
    
    em.persist(member);
    ```
    
- **양방향 매핑시 연관관계의 주인에 값을 입력해야 함**
    
    ```java
    Team team = new Team();
    team.setName("TeamA");
    em.persist(team);
    
    Member member = new Member();
    member.setName("member1");
    
    team.getMembers().add(member);
    //연관관계의 주인에 값 설정
    member.setTeam(team); //**
    
    em.persist(member);
    ```
    
- **양방향 매핑에서는 양쪽에 모두 값을 넣어주는 게 좋다**
- 양쪽 값을 입력 하지 않은 경우 문제점
    - **flush, clear을 하지 않는 경우**
        - team을 영속 엔티티로 등록 → 1차 캐쉬로 저장
        - 이 때, 영속성 컨텍스트를 정리하지 않고 Team의 컬렉션 members를 조회하면 캐시에 남아있는 빈 리스트를 가져온다. (new ArrayList로 초기화 됨)
    - test 하는 경우
        - test case에서는 JPA를 이용하기 보다는 순수한 객체를 이용
        - jpa가 연관관계를 넣어주지 못하므로, 양쪽 객체에 값을 넣어줘야 매핑 가능
- **연관관계 편의 메서드를 사용**
    - 양쪽에 있을 경우 문제의 소지가 될 확률이 높으니 한 쪽에만 생성
    
    ```java
    // Member Entity 편의 메서드
    public void changeTeam(Team team) { // 로직이 섞여있을 경우 Getter, Setter 사용을 피하자.
        this.team = team;
        team.getMembers().add(this);
    }
    
    // Team Entity 편의 메서드 -> Member Entity에서 정의 했기 때문에 없어도 됨
    public void addMember(Member member) {
        member.setTeam(this);
        members.add(member);
    }
    ```
    
- 양방향 매핑시 무한 루프 조심
    - 예: toString(), lombok, JSON 생성 라이브러리
    - 컨트롤러에서 Entity를 절대 반환하지 말고 DTO로 반환할 것
        - JSON 생성 시 무한 루프 가능성
        - 엔티티 변경 시 API Spec이 변경됨
- **단방향 매핑만으로 연관관계 매핑은 완료된다 →** **단방향으로 설계 후 추가**