# 6. 고급 매핑

# 상속관계 매핑

- **객체에는 상속 관계가 있지만, 관계형 데이터베이스는 상속 관계가 없다.**
- 관계형 데이터베이스의 **`슈퍼타입 서브타입 관계`** 모델링 기법이 그나마 객체 상속과 유사하다.
- `상속관계 매핑`: 객체의 상속과 구조와 DB의 `슈퍼타입 서브타입 관계`를 매핑하는 것이다.

![Untitled](6%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%201558dff2968245c09195350bd34931e9/Untitled.png)

## 구현 방법

- 조인 전략: 각각 모두 테이블로 만들고 조회할 때 조인을 사용
- 단일 테이블 전략 (default): 테이블을 하나만 사용해서 통합
- 구현 클래스마다 테이블 전략: 서브 타입마다 하나의 테이블을 만든다

### 주요 **어노**테이션

- @Inheritance(strategy = [InheritanceType.XXX](http://inheritancetype.xxx/))
    - JOINED - 조인 전략
    - SINGLE_TABLE - 단일 테이블 전략 (default)
    - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
- @DiscriminatorColumn(name="DTYPE")
    - 부모 클래스에 선언. **하위 클래스를 구분하는 용도의 컬럼**
- @DiscriminatorValue("XXX")
    - 하위 클래스에 선언. 엔티티를 저장할 때 슈퍼타입의 구분 컬럼에 저장할 값을 지정

## 조인 전략

![Untitled](6%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%201558dff2968245c09195350bd34931e9/Untitled%201.png)

**엔티티 각각을 테이블로 만들고**, 자식 테이블이 부모의 기본키를 `기본키 + 외래키`로 사용한다.

기본 값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용한다.

**만약, 자식 테이블의 기본 키 컬럼명을 변경하고 싶을 때는 `@PrimaryKeyJoinColumn` 을 사용하면 된다.**

```java
@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name = "BOOK_ID")  // ID 재정의
public class Book extends Item {

    private String author;   // 작가
    private String isbn;     // ISBN
    ...
}
```

- **장점**
    - 테이블이 **정규화**된다.
    - **외래 키 참조 무결성 제약조건을 활용**할 수 있다.
    - **저장공간을 효율적으로 사용**한다. (불필요하게 `null`을 넣는 부분이 없다)
- **단점**
    - 조회시 조인을 많이 사용해서 성능이 저하된다.
    - 조회 쿼리가 복잡하다.
    - 데이터 저장시 `INSERT SQL` 2번 호출해야 한다

## 단일 테이블 전략

![Untitled](6%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%201558dff2968245c09195350bd34931e9/Untitled%202.png)

> 서비스 규모가 크지 않고, 조인 전략을 선택해서 복잡하게 갈 필요가 없을 때 사용한다
> 
- **한 테이블에 저장한 뒤, `DTYPE`으로 구분**한다.
- 저장된 서브 타입마다 사용하지 않는 컬럼들에는 `null` 이 들어간다.
- `INSERT`, `SELECT` 쿼리 모두 한 번 실행
- **장점**
    - **조인이 필요 없으므로** 일반적으로 **조회 성능이 빠르다.**
    - 조회 쿼리가 단순하다.
- **단점**
    - **자식 엔티티가 매핑한 컬럼은 모두 `null`을 허용**해야 한다. (데이터 관점에서 좋지 않다)
    - 단일 테이블에 모든 것을 저장하므로 **테이블이 커질 수 있다.**
    - 상황에 따라서 **조회 성능이 오히려 느려질 수 있다.**

## **구현 클래스마다 테이블 전략 (사용 X)**

![Untitled](6%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%201558dff2968245c09195350bd34931e9/Untitled%203.png)

**장점**

- 서브 타입을 명확하게 구분해서 처리할 때 효과적
- not null 제약조건 사용 가능

**단점**

- 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
- 자식 테이블을 통합해서 쿼리하기 어려움

<aside>
💡 **전략 선택**

- 기능이 단순하고 확장 가능성도 적으면 **단일 테이블 전략**
- 비즈니스적으로 중요하고, 복잡하고, 확장 가능성이 높으면 **조인 전략**
</aside>

# **Mapped Superclass - 매핑 정보 상속**

### **@MappedSuperclass**

> **객체 입장**에서 **공통 매핑 정보가 필요할 때 사용**
> 

![Untitled](6%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%201558dff2968245c09195350bd34931e9/Untitled%204.png)

- 엔티티가 아니며, 테이블과 매핑이 아니다.
- 부모 클래스를 상속 받는 **자식 클래스에 매핑 정보만 제공**
- 부모 타입으로 **조회, 검색 불가 (`em.find(BaseEntity)` 불가)**
- 직접 생성해서 사용할 일이 없으므로 **추상 클래스 권장**
- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 **공통으로 적용하는 정보를 모을 때 사용**

<aside>
💡 참고
`@Entity` 클래스는 엔티티나 `@MappedSuperclass`로 지정한 클래스만 상속 가능

</aside>