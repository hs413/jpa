# 2. 영속성

<aside>
💡 **JPA에서 가장 중요한 두 가지!**

- 객체와 RDB 매핑하기 (ORM) → 설계 관련
- **영속성 컨텍스트** → 실제 JPA가 내부적으로 어떻게 동작하는지 관련
</aside>

## **엔티티 매니저 팩토리와 엔티티 매니저**

![Untitled](2%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%207c71a2bf8e284cfcb010e9c07afdb188/Untitled.png)

- 웹 애플리케이션이 실행될 때 `EntityManagerFactory`가 생성된다.
- 클라이언트의 요청이 올 때마다 `EntityManage`를 생성하여 커넥션 풀을 사용해서 DB에 접근한다.

### EntityManagerFactory

- 데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 하나만 생성한다.
- 엔티티 매니저를 만드는 공장. 비용이 상당히 크다.
- 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유 가능

### EntityManager

- 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.
- 엔티티를 저장하는 가상의 데이터베이스로 생각하면 된다.
- 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간 절대로 공유 금지

```java
// 매니저 팩토리
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");

// 엔티티 매니저 생성
EntityManager em = emf.createEntityManager();
```

## **영속성 컨텍스트**

- **JPA를 이해하는데 가장 중요한 용어 → 엔티티를 영구 저장하는 환경**
- EntityManager.persist(entity) → 영속성 컨텍스트에 엔티티를 저장한다는 의미
- **논리적인 개념**으로, 눈에 보이지 않음
- **엔티티 매니저를 통해서 접근**한다.

## 엔티티 생명 주기

![Untitled](2%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%207c71a2bf8e284cfcb010e9c07afdb188/Untitled%201.png)

### 1. 비영속 (new/transient)

- 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.
- 객체 생성, 초기화만 된 상태

```java
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

### 2. 영속 (managed)

- 영속성 컨텍스트에 관리되는 상태

```java
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

// 객체를 저장한 상태 (영속)
em.persist(member);
```

- 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.
- 영속 상태가 된다고 해서 바로 DB에 쿼리가 날라가는 것은 아니다. → 이후에 커밋해야 저장된다.

### 3. 준영속 (detached)

- 영속성 컨텍스트에 관리되다가 더 이상 관리 받지 않는 상태
- **영속성 컨텍스트에서 삭제하는 것**

```java
em.detach(member);
// em.close()를 호출해서 영속성 컨텍스트를 닫거나,
// em.clear()를 호출해서 영속성 컨텍스트를 초기화해도 
// 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다.
```

### 4. 삭제 (removed)

- **실제로 DB에서 해당 ROW를 삭제하는 것**

```java
em.remove(member);
```

## 영속성 컨텍스트의 이점

### 1. 엔티티 조회 - 1차 캐시

- 저장
    
    ```java
    // 엔티티를 생성한 상태 (비영속)
    Member member = new Member();
    member.setId("member1");
    member.setUsername("회원1");
    
    // 엔티티를 영속
    em.persist(member);
    ```
    
    - 객체를 생성하고 `persist`하면 영속성 컨텍스트 내부의 1차 캐시에 저장된다.
    - `key-value로` 저장되며, `key`는 `member1`, `value`는 `member` 객체가 담긴다.
- 1차 캐시 조회
    
    ```java
    Member member = new Member();
    member.setId("member1");
    member.setUsername("회원1");
    
    //1차 캐시에 저장됨
    em.persist(member);
    
    //1차 캐시에서 조회
    Member findMember = em.find(Member.class, "member1");
    ```
    
    - **`JPA`는 엔티티 조회할 때 1차 캐시부터 찾는다.**
    - 1차 캐시에서 해당되는 키값을 가진 엔티티가 있다면, 1차 캐시에서 조회해온다.
- DB 조회
    
    ```java
    // 1차 캐시에 없는 값은 DB에서 조회 후 1차 캐시에 저장
    Member findMember2 = em.find(Member.class, "member2");
    ```
    
    - 1차 캐시에 없으면 DB에서 조회 객체를 1차 캐시에 저장 후 반환한다.

### 2. 영속 엔티티의 동일성 보장

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b);	// true
```

- 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 **애플리케이션 차원**에서 제공

### 3. 엔티티 등록 - **트랜잭션을 지원하는** 쓰기 지연

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
//엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.
transaction.begin(); // [트랜잭션] 시작

em.persist(memberA);
em.persist(memberB);
//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

//커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit(); // [트랜잭션] 커밋
```

- `em.persist(memberA);`로 `memberA`를 1차 캐시에 넣는다.
- 1차 캐시에 저장됨과 동시에 `JPA`가 해당 엔티티를 분석해서 `INSERT SQL` 생성해서 쓰기 지연 `SQL` 저장소에 쌓아둔다.
    
    ![Untitled](2%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%207c71a2bf8e284cfcb010e9c07afdb188/Untitled%202.png)
    
- `em.persist(memberB);`도 동일하게, 1차 캐시에 넣고 `INSERT SQL` 생성해서 쓰기 지연 `SQL` 저장소에 쌓아둔다.
    
    ![Untitled](2%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%207c71a2bf8e284cfcb010e9c07afdb188/Untitled%203.png)
    
- `transaction.commit();`하는 시점에 쓰기 지연 `SQL` 저장소에 쌓인 `SQL`문들이 한꺼번에 날아간다. (`flush`)
    
    ![Untitled](2%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%207c71a2bf8e284cfcb010e9c07afdb188/Untitled%204.png)
    

<aside>
💡 **쓰기 지연을 사용하는 이유**

버퍼링 기능으로 인해 쿼리를 여러 번 날리지 않고 최적화가 가능하기 때문

</aside>

### 4. 엔티티 수정 - 변경 감지 (**Dirty Checking**)

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin(); // [트랜잭션] 시작

// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");

// 영속 엔티티 데이터 수정
memberA.setUsername("hi");
memberA.setAge(10);

//em.update(member) 없어도 됨

transaction.commit(); // [트랜잭션] 커밋
```

![Untitled](2%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%207c71a2bf8e284cfcb010e9c07afdb188/Untitled%205.png)

- 영속 컨텍스트의 1차 캐시에는 스냅샷이 저장되어 있다
    - 스냅샷: 엔티티 값을 읽어 온 최초 시점의 엔티티 데이터
- commit시점 엔티티 매니저 내부에서 flush가 실행되면서 엔티티와 스냅샷을 비교해서 변경 데이터를 감지한다. (변경 감지)
- 변경 사항이 있다면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소 쌓아둔다.
- 쓰기 지연 SQL 저장소의 `UPDATE SQL`을 데이터베이스에 보낸다.
- 데이터베이스 트랜잭션을 커밋한다

<aside>
💡 **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.**

비영속, 준영속처럼 관리를 받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.

</aside>

### 5. 엔티티 삭제

```java
//삭제 대상 엔티티 조회
Member memberA = em.find(Member.class, “memberA");

em.remove(memberA); //엔티티 삭제
```

- `em.remove()`에 삭제 대상 엔티티를 넘겨주면 엔티티를 삭제한다.
- 삭제된 엔티티는 재사용하지 말고 자연스럽게 가바지 컬렉션의 대상이 되도록 두는 것이 좋다.

### 영속성 컨텍스트의 특징

- 영속성 컨텍스트는 엔티티를 식별자(`@Id`로 테이블의 기본 키와 매핑한 값)로 구분한다.
    - **영속 상태는 식별자가 반드시 있어야 한다.**
    - 없으면 예외가 발생한다.
- 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이를 플러시라고 한다.

## 플러시 (Flush)

### **1. 플러시 발생**

- **변경 감지를 발견하면 수정된** 엔티티를 찾는다
- 수정된 엔티티는 수정 쿼리를 만들어 **쓰기 지연 SQL 저장소**에 등록한다.
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)한다.

### **2. 영속성 컨텍스트 플러시 호출 방법**

- em.flush() - 직접 호출
    - 영속성 컨텍스트를 강제로 플러시한다.
    - 테스트나 다른 프레임워크나 JPA를 함께 사용할 때를 제외하고 거의 사용하지 않는다.
- 트랜잭션 커밋 : 자동 호출
- `JPQL` 쿼리 실행 : 자동 호출
    - **JPQL 실행 시 자동으로 호출되는 이유 →** DB와 영속성 컨텍스트간에 동기화를 위해
    
    ```java
    em.persist(memberA);
    em.persist(memberB);
    em.persist(memberC);
    
    // 중간에 JPQL 실행
    // 등록한 member들이 조회가 안되는 경우를 막기 위해 자동으로 플러시가 호출된다.
    query = em.createQuery("select m from Member m", Member.class);
    List<Member> members= query.getResultList();
    ```
    

### **3. 플러시 모드 옵션**

```java
// 플러시 모드를 직접 지정하려면 FlushModeType을 사용하면 된다.
em.setFlushMode(FlushModeType.COMMIT)
```

- `FlushModeType.AUTO` : 커밋이나 쿼리를 실행할 때 플러시 **(기본 값) - 권장**
- `FlushModeType.COMMIT` : 커밋할 때만 플러시

<aside>
💡 **플러시 정리**

- **영속성 컨텍스트를 비우는 것이 아닌, 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화**하는 것 (1차 캐시 등은 남아있는다)
- 트랜잭션이라는 작업 단위가 중요하다. → **트랜잭션 커밋 직전 변경 내용을 데이터베이스에 보내서 동기화 하면 된다.**
</aside>

## 준영속 상태

- 영속 → 준영속
- **영속 상태의 엔티티가 영속성 컨텍스트에서 분리 (`detached`)**
- 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.

### 준영속 상태로 만드는 방법

- `em.detach(entity)`: 특정 엔티티만 준영속 상태로 전환
- `em.clear()`: 영속성 컨텍스트를 완전히 초기화
- `em.close()`: 영속성 컨텍스트를 종료

### 준영속 상태의 특징

- 비영속 상태에 가깝다.
    - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.
- 식별자를 가지고 있다.
    - 비영속 상태는 식별자가 없을 수도 있지만 준영속 상태는 영속 상태였으므로 반드시 식별자를 가지고 있다.
- 지연 로딩을 할 수 없다.
    - 지연 로딩(LAZY LOADING)은 실제 객체 대신 프록시 객체를 로딩 해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법
    - 준영속 상태는 영속성 컨텍스트가 관리하지 않으므로 지연 로딩 시 문제가 발생