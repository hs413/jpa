# 3. 엔티티 매핑

<aside>
💡 **엔티티 매핑**

- 객체와 테이블 매핑 : `@Entity`, `@Table`
- 필드와 컬럼 매핑 : `@Column`
- 기본 키 매핑 : `@Id`
- 연관관계 매핑 : `@ManyToOne`, `@JoinColumn`
</aside>

# 객체와 테이블 매핑

## @Entity

- **@Entity가 붙은 클래스는 JPA가 관리하며, 이를 엔티티라고 한다.**
- JPA를 사용해서 테이블과 매핑할 클래스는 `@Entity` 필수
- **주의 사항**
    - **기본 생성자 필수** (파라미터가 없는 `public` 또는 `protected` 생성자)
    - `final`, `enum`, `interface`, `inner` 클래스는 사용 ❌
    → 해당 클래스는 `@Entity`를 붙여서 DB Table과 매핑할 수 없다.
    - DB에 저장할 필드에 `final` 사용 ❌

### 속성

- name
    
    ```java
    @Entity(name = "Member")
    public class Member { ... }
    ```
    
    - JPA에서 사용할 엔티티 이름을 지정한다.
    - 기본 값: **클래스 이름을 그대로 사용**한다. - Ex) `Member`
    - 같은 클래스 이름이 없으면 가급적 기본 값을 사용한다.

## @Table

- **엔티티와 매핑할 테이블을 지정한다.**
- 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.

```java
@Entity
@Table(name = "MBR")
public class Member { }

// -> MBR 테이블을 사용하는 쿼리가 생성
```

| 속성 | 기능 | 기본 값 |
| --- | --- | --- |
| name | 매핑할 테이블 이름 | 엔티티 이름을 사용 |
| catalog | 데이터베이스 catalog 매핑 |  |
| schema | 데이터베이스 schema 매핑 |  |
| uniqueConstraints (DDL) | DDL 생성 시에 유니크 제약 조건 생성 |  |

# **스키마 자동 생성**

- JPA에서는 **애플리케이션 실행 시점에 `DDL`을 자동으로 생성**한다.
- 테이블 중심 → 객체 중심
- **데이터베이스 방언**을 활용해서 **데이터베이스에 맞는 적절한 DDL 생성!**
- 이렇게 **생성된 DDL은 개발 장비에서만 사용한다.**
    - 운영 서버에서는 사용하지 않거나, 적절히 다듬은 후 사용.

### **hibernate.hbm2ddl.auto 속성**

| 옵션 | 설명 |
| --- | --- |
| create | 기존 테이블 삭제 후 다시 생성 (DROP + CREATE) |
| create-drop | create와 같으나 종료 시점에 테이블 DROP |
| update | 변경만 반영(운영DB에는 사용하면 안됨) |
| validate | 엔티티와 테이블이 정상 매핑 되었는지만 확인 |
| none | 사용하지 않음 |
- 테스트 서버에서는 `create`를 사용하면 안된다. (이전 입력 했던 데이터들이 다 날라간다.)
- 웹 애플리케이션에서는 `alter`, `drop`을 사용하면 안된다.
- 운영 장비에는 절대 `create`, `create-drop`, `update` 사용하면 안된다.
- 개발 초기 단계는 `create` 또는 `update`
- 테스트 서버는 `update` 또는 `validate`
- 스테이징과 운영 서버는 `validate` 또는 `none`

### DDL 생성 기능

- 제약 조건 추가: 회원 이름은 필수, 10자 초과
    
    ```java
    @Column(nullable = false, length=10)
    ```
    
- 유니크 제약 조건 추가
    
    ```java
    @Table(uniqueConstraints = {
    		@UniqueConstraint(name = "NAME_AGE_UNIQUE", columnNames = {"NAME", "AGE"} )})
    ```
    

> DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.
> 

## 필드와 컬럼 매핑

### **매핑 애노테이션 정리**

| 어노테이션 | 설명 |
| --- | --- |
| @Column | 컬럼 매핑 |
| @Temporal | 날짜 타입 매핑 |
| @Enumerated | enum 타입 매핑 |
| @Lob | BLOB, CLOB 매핑 |
| @Transient | 특정 필드를 컬럼에 매핑하지 않음(매핑 무시) |
- **@Column**
    
    ![Untitled](3%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ece81c87199e4412b354531ea62c4db1/Untitled.png)
    
    - unique는 @Table에서 사용하는 것을 권장
- @Enumerated
    - **자바 `enum` 타입을 매핑**할 때 사용
    
    ![Untitled](3%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ece81c87199e4412b354531ea62c4db1/Untitled%201.png)
    
    - **`ORDINAL` 사용 X → 타입이 추가/변경/삭제되어 순서가 달라질 경우 문제가 발생**
- @Temporal
    - **날짜 타입(`java.util.Date`, `java.util.Calendar`)을 매핑**할 때 사용
    
    ![Untitled](3%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ece81c87199e4412b354531ea62c4db1/Untitled%202.png)
    
    - `LocalDate`, `LocalDateTime`을 사용할 때는 생략 가능 (최신 하이버네이트 지원)
    - `@Temporal`을 생략하면 `timestamp`로 정의된다.
- @Lob
    - **데이터베이스 `BLOB`, `CLOB` 타입과 매핑**
    - 지정할 수 있는 속성이 없다.
    - 매핑하는 필드 타입이 문자면 `CLOB` 매핑, 나머지는 `BLOB` 매핑
        - `CLOB`: `String`, `char[]`, `java.sql.CLOB`
        - `BLOB`: `byte[]`, `java.sql.BLOB`
- @Transient
    - **필드 매핑이 안되게 하는 어노테이션**
    - 데이터베이스에 저장 및 조회 X
    - **메모리 상에서만** 임시로 어떤 값을 보관하고 싶을 때 사용

## 기본 키 매핑

### **매핑 어노테이션**

- `@Id`
- `@GeneratedValue`

```java
@Id @GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
```

### **매핑 방법**

- 직접 할당: **`@Id`만 사용**
    - 기본 키를 애플리케이션에서 직접 할당한다.
- 자동 생성(**`@GeneratedValue`**): 대리 키 사용 방식
    - **`IDENTITY`**: 데이터베이스에 위임, MYSQL
    - **`SEQUENCE`**: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
        - `@SequenceGenerator` 필요
    - **`TABLE`**: 키 생성용 테이블 사용, 모든 DB에서 사용
        - `@TableGenerator` 필요
    - **`AUTO`**: 방언에 따라 자동 지정, 기본값

### **IDENTITY 전략**

- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용한다.
    - Ex) MySQL의 `AUTO_ INCREMENT`
- JPA는 보통 트랜잭션 커밋 시점에 `INSERT SQL`을 실행한다.
    - **`AUTO_ INCREMENT`는 데이터베이스에 `INSERT SQL`을 실행한 이후에 ID 값을 알 수 있다.**
    - 기본 키 생성을 데이터베이스에 위임 → DB 저장 시 식별자를 알지 못함
    - **영속성 컨텍스트에 저장**하려면 **식별자를 알아**야 한다
    - 따라서 `IDENTITY` 전략은 persist 시점에 즉시 `INSERT SQL` 실행하고 DB에서 식별자를 조회
    - 조회한 식별자를 가지고 영속성 컨텍스트에 등록
    - IDENTITY 전략에서는 **모아서 한번에** insert하는 전략이 **불가능**하다
- 먼저 엔티티를 데이터베이스에 저장한 후에 식별자를 조회해서 엔티티의 식별자에 할당한다.

### **SEQUENCE 전략**

- 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용
- 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트
- `@SequenceGenerator`라는 **시퀀스 생성자가 필요**
    
    ```java
    @Entity 
    @SequenceGenerator( 
            name = “MEMBER_SEQ_GENERATOR", 
            sequenceName = “MEMBER_SEQ", //매핑할 데이터베이스 시퀀스 이름
            initialValue = 1, allocationSize = 1)
    public class Member { 
        @Id 
        @GeneratedValue(strategy = GenerationType.SEQUENCE, 
                        generator = "MEMBER_SEQ_GENERATOR") 
        private Long id; 
    ```
    
- `em.persist()`를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회한다.
    - 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다.
    - 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를 데이터베이스에 저장한다.
    
    ![Untitled](3%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ece81c87199e4412b354531ea62c4db1/Untitled%203.png)
    
- **allocationSize**
    - sequence를 얻기 위해서는 select를 해야 하기 때문에 **db와 통신 필요**
    - **allocationSize를 지정하면 한번 select 시 size 만큼 가져 온 뒤 메모리에 할당**
    - 메모리에 할당된 sequence 사용 → **db와 통신을 줄여 성능을 최적화**
    - 전부 사용하면, **시퀀스를 다시 호출**
    - 동시성 문제 해결
        - 2명의 클라이언트가 접근 한 경우
        - 첫 번째 클라이언트는 1~50의 식별자를 할당
        - 두 번째 클라이언트는 51~100의 식별자를 할당
        - 중복되지 않음

### **TABLE 전략**

- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
- **모든 데이터베이스에 적용이 가능**하지만, **성능이 떨어진다.**
- 운영에서는 잘 사용하지 않는다.
    
    ```sql
    // 테이블 생성
    create table MY_SEQUENCES (
        sequence_name varchar(255) not null,
        next_val bigint,
        primary key ( sequence_name )
    )
    ```
    
    ```java
    @Entity
    @TableGenerator(
            name = "MEMBER_SEQ_GENERATOR",
            table = "MY_SEQUENCES",
            pkColumnValue = “MEMBER_SEQ", allocationSize = 1)
    public class Member {
        @Id
        @GeneratedValue(strategy = GenerationType.TABLE,
                        generator = "MEMBER_SEQ_GENERATOR")
        private Long id;
    ```
    

![https://velog.velcdn.com/images%2Fmmy789%2Fpost%2Fbeb4fac9-b292-4e37-ab6a-215046ee3b2f%2Fimage.png](https://velog.velcdn.com/images%2Fmmy789%2Fpost%2Fbeb4fac9-b292-4e37-ab6a-215046ee3b2f%2Fimage.png)

### 3. 권장하는 식별자 전략

- **기본 키 제약 조건**: `null` 아님 (`NOT NULL`), 유일 (`UNIQUE`), **변하면 안된다.**
    - 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다 → **대리키(대체키)를 사용**
- **권장**: **`Long`형 + 대체키(** `IDENTITY`, `SEQUENCE`, `UUID`) **+ 키 생성 전략**