# 1. 개요

## SQL 중심 개발의 문제점

### **객체와 관계형 데이터베이스의 차이**

- 상속
    
    ![image](https://github.com/hs413/jpa/assets/160138990/267f1e3a-45d6-4c76-abc0-d52eed8cfda0)

    
    DB에 저장할 객체에 상속을 사용하지 않음 (복잡함)
    
    - **ALBUM 객체 저장**, ITEM과 ALBUM 데이터를 모두 저장해야 한다.
        
        ```sql
        INSERT INTO ITEM ...
        INSERT INTO ALBUM …
        ```
        
    - **ALBUM 객체 조회**
        - 각각의 테이블에 따른 조인 SQL 작성
        - 각각의 객체 생성 등.. 복잡
- 연관관계
  
    ![image](https://github.com/hs413/jpa/assets/160138990/8f6b5412-2804-4d4d-b1e9-5943ab04fefc)
    
    테이블은 외래 키를 사용하기 때문에 보통 객체를 테이블에 맞추어 모델링한다.
    
    ```java
    class Member {
    	String id;		// MEMBER_ID
    	Long teamId;	// TEAM_ID FK
        String username;// USERNAME
    }
    
    class Team {
    	Long id;		// TEAM_ID PK
    	String name;	// NAME
    }
    
    // 조회 
    public Member find(String memberId) {
        // SQL 실행
        Member member = new Member();
        // 데이터베이스에서 조회한 회원 관련 정보 입력
        Team team = new Team();
        // 데이터베이스에서 조회한 팀 관련 정보 입력
        
        // 회원과 팀 관계 설정
        member.setTeam(team);
        return member;
    }
    ```
    
- 객체 그래프 탐색
    
    실행하는 SQL에 따라 탐색 범위가 결정되기 때문에 불가능
    
    ```java
    // 엔티티 신뢰 문제
    
    // SQL
    SELECT M.*, T.*
      FROM MEMBER M
      JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
      
    // 자바 코드
    class MemberService {
        public void process() {
            Member member = memberDAO.find(memberId);
            member.getTeam(); // 사용 가능한가?
            member.getOrder().getDelivery(); // 사용 가능한가?
        }
    }
    
    // 계층 아키텍쳐에서는 이전 계층에서 넘어온 내용을 신뢰할 수 있어야 한다.
    // 하지만 SQL에서 탐색된 객체 이외에는 사용할 수 없으므로 엔티티를 신뢰할 수 없다. 
    // 모든 객체를 미리 로딩할 수 없음 -> 동일한 회원 조회 메서드를 여러 번 생성해야 함
    ```
    
- 비교하기
    
    ```java
    String memberId = "100";
    Member member1 = memberDAO.getMember(memberId);
    Member member2 = memberDAO.getMember(memberId);
    
    member1 == member2; // false
    ```
    

## JPA (Java Persistence API)

자바 진영의 **ORM 기술 표준**

### ORM (**Object-Relational Mapping)**

- 객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스대로 설계한다.
    - ORM 프레임워크가 중간에서 이를 매핑한다.
- 대중적인 언어에는 대부분 ORM 기술이 존재한다.

## **JPA 동작**

![image](https://github.com/hs413/jpa/assets/160138990/4f16733c-b282-4a58-938d-3849d3cced00)


- JPA는 애플리케이션과 JDBC 사이에서 동작한다.
- 개발자가 JPA를 사용하면 JPA 내부에서 JDBC API를 사용해서 SQL을 호출해서 DB와 통신한다.
- **개발자가 직접 JDBC API를 사용하지 않음**

### 1. 저장

![image](https://github.com/hs413/jpa/assets/160138990/9f853f5b-5c75-44fb-a836-ce17f1f07f81)

1. MemberDAO에서 객체를 저장하기 위해서 Member 객체를 JPA에 넘긴다.
2. JPA는 Member 객체를 분석 후 적절한 INSERT query를 생성한다.
3. JPA가 내부적으로 JDBC API를 사용하여 INSERT query를 DB에 보낸다.

### 2. 조회

![image](https://github.com/hs413/jpa/assets/160138990/c645f243-618a-46f3-9669-4f956d3c29dc)

1. JPA에 조회 요청하면 JPA가 내부적으로 JDBC API를 사용해서 ResultSet을 가져온다.
2. JPA가 ResultSet을 객체에 매핑해준다.

## **JPA 표준 명세**

- JPA는 인터페이스의 모음이다.
- JPA 2.1 표준 명세를 구현한 3가지 구현체
    - 하이버네이트, EclipseLink, DataNucleus → 이 중 대부분 하이버네이트를 사용한다.

## **JPA 사용 이유**

### 1. SQL 중심적인 개발에서 객체 중심으로 개발

### 2. 생산성

**기본적인 CRUD 코드가 구현되어 있다.**

- 저장: jpa.persist(member)
- 조회: Member member = jpa.find(memberId)
- 수정: member.setName(“변경할 이름”)
- 삭제: jpa.remove(member)

### 3. 유지보수

- 기존: 필드 변경 시 모든 SQL 수정

  ![image](https://github.com/hs413/jpa/assets/160138990/b0f34cff-0219-4543-8a51-2e25834e490d)
    
- JPA: 필드만 추가하면 된다. SQL은 JPA가 처리

  ![image](https://github.com/hs413/jpa/assets/160138990/d7d33cc2-a07f-48de-ae4d-1ebcf587dbdf)
    

### 4. 패러다임의 불일치 해결

- 상속
    
    ```java
    // 개발 코드
    // 저장
    jap.persist(album)
    
    // 조회
    Album album = jpa.find(Album.class, albumId);
    ```
    
    ```sql
    -- JPA가 처리
    -- 저장
    INSERT INTO ITEM ...
    INSERT INTO ALBUM ...
    
    -- 조회
    SELECT I.*, A.*
    	FROM ITEM I
    	JOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID
    ```
    
- 연관관계와 객체 그래프 탐색
    
    ```java
    // 연관관계 저장
    member.setTeam(team);
    jpa.persist(member);
    
    // 객체 그래프 탐색
    Member member = jpa.find(Member.class, memberId);
    Team team = member.getTeam();
    
    // 신뢰할 수 있는 엔티티, 계층
    class MemberService {
    	public void process() {
    		Member member = memberDAO.find(memberId);
    		// 자유로운 객체 그래프 탐색이 가능하다.
    		member.getTeam();
    		member.getOrder().getDelivery();
    	}
    }
    
    ```
    
- 비교하기
    
    ```java
    String memberId = "100";
    Member member1 = jpa.find(Member.class, memberId);
    Member member2 = jpa.find(Member.class, memberId);
    
    member1 == member2;	// true
    ```
    
    **동일한 트랜잭션 안에서 조회한 엔티티는 같음**을 보장
    

### 5. 성능

- 1차 캐시와 동일성(identity) 보장
    - 같은 트랜잭션 안에서는 같은 엔티티를 반환 → 약간의 조회 성능 향상
    - DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장
- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
    - 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
    - JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
    - UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화
    - 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고, 바로 커밋
- 지연 로딩(Lazy Loading)
    - 지연 로딩: 객체가 실제 사용될 때 로딩
    - 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회
    
    ![image](https://github.com/hs413/jpa/assets/160138990/8336045b-04b0-4755-ae8e-e35b35aaf76b)
    

### 6. 데이터 접근 추상화와 벤더 독립성

### 7. 표준

## 데이터베이스 방언

- JPA는 특정 데이터베이스에 종속되지 않
- 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름
    - 가변 문자 : MySQL은 VARCHAR, Oracle은 VARCHAR2
    - 문자열을 자르는 함수 : SQL 표준은 SUBSTRING(), Oracle은 SUBSTR()
    - 페이징 : MySQL은 LIMIT , Oracle은 ROWNUM
- **방언** : **SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능**

**데이터베이스 방언 (dialect)**

![image](https://github.com/hs413/jpa/assets/160138990/a4e26f74-d3c6-4ae1-9e10-03f6e2bf752b)

## **JPA 구동 방식**

![image](https://github.com/hs413/jpa/assets/160138990/0befb5f3-a157-40a8-aa82-619fc0570ec7)

- JPA는 Persistence라는 클래스가 있다.
- Persistence에서 persistence.xml 설정 정보를 읽어서 EntityManagerFactory 객체를 생성해준다.
- EntityManagerFactory에서 필요할 때마다 EntityManager를 생성해서 사용한다.

### 주의사항

- **엔티티 매니저 팩토리는 하나만 생성**해서 애플리케이션 전체에서 공유한다.
- 엔티티 매니저는 스레드 간에 공유 X (사용하고 버려야 한다.)
- **JPA의 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다!**

## JPQL

> **식별자를 통한 단순 조회가 아닌 추가 조건들을 통해 조회**하고 싶을 때 사용한다
> 
- JPA를 사용하면 엔티티 객체를 중심으로 개발한다.
- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색한다 .
→ 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 검색 조건이 포함된 SQL이 필요하다.

### JPQL, SQL 비교

- JPQL
    - **엔티티 객체를 대상**으로 쿼리한다.
    - DB를 바꾸더라도 방언을 교체할 필요가 없다
    - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다
- SQL: **데이터베이스 테이블**을 대상으로 쿼리한다
